#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "tuneable.h" 
#include "logh.h" 
#include "fitsio.h" 
#include "cast_arr.h" 
#include "newfits.h" 

// write a brand new output fits file
// either automatically creating a minimalistic header
// or retreiving an exsiting one from another file

//inputs: the number of columns and rows in pixels, the 2d image array, 
//the (null terminated) name of the output file
//get_head = 1 if a header should be retreived from another file with name r_file
//get_head = 0 (or anything not 1) if a fresh, automatic header should be
//        generated by fitsio 
//get_head will actually copy the whole file over and the rewrite the data portion
// of the file with the new array, so header NAXIS info must be the same

void newfits_(int nx, int ny, int** pic, char* w_file, int get_head, char* r_file){

     int lverb = tune14_.lverb;
     int fio_err = 0; // for reporting file opening and writing errors
     char* force_file = malloc((strlen(w_file)+2)*sizeof(char));
     force_file[0] = '!';
     strncpy(force_file+1, w_file, strlen(w_file));
     force_file[strlen(w_file)+1] = '\0';

     //opening a old file if requested
     fitsfile* old_fptr;
     int old_img_type = 0;
     if(get_head == 1){
          if (lverb > 10){
               fprintf(logfile, 
                    "newfits: copying header from %s to %s \n", w_file, r_file);
          }
          fits_open_file(&(old_fptr), r_file, 0, &fio_err);
          if (fio_err != 0){
               printf("newfits_ fitsio error in open_file: %d\n", fio_err);
               printf("     proceeding with minimal fits header in output\n");
               fits_close_file(old_fptr, &fio_err);
               fio_err = 0;
               get_head = 0;
          }
          fits_get_img_type(old_fptr, &old_img_type, &fio_err);
          if( (old_img_type != (-32)) && (old_img_type != (32)) ){
               printf("newfits_ old img is different size than new img");
               printf("     bitpix old = %d\n", old_img_type);
               printf("     proceeding with minimal fits header in output\n");
               fits_close_file(old_fptr, &fio_err);
               fio_err = 0;
               get_head = 0;
          }
     }
     else{
          if (lverb > 10){
               fprintf(logfile, 
                    "newfits: creating minimal header for %s \n", w_file);
          }
          get_head = 0;
     }
     
     //opening a new file
     fitsfile* fptr;
     fits_create_file(&(fptr), force_file, &fio_err);
     if (fio_err != 0){
          printf("newfits_ fitsio error in create_file: %d\n", fio_err);
          fits_close_file(fptr, &fio_err); 
          if(get_head == 1) fits_close_file(old_fptr, &fio_err);
          return;
     }          
     free(force_file);

     //copy image or create image
     //copy image
     if (get_head == 1){
          fits_copy_file(old_fptr, fptr, 1, 1, 1, &fio_err);
          if (fio_err != 0){
               printf("newfits_ fitsio error in copy_image: %d\n", fio_err);
               printf("     proceeding with minimal fits header in output\n");
               if (lverb > 10){
                    fprintf(logfile, 
                         "newfits: creating minimal header for %s \n", w_file);
               }
               fits_close_file(old_fptr, &fio_err);
               fio_err = 0;
               get_head = 0;
          } 
          fits_close_file(old_fptr, &fio_err); 
          if (fio_err != 0){
               printf("newfits_ fitsio error in close_file (old): %d\n", fio_err);
               return;
          }          
     } 

     //create image
     short int fpixel = 1;
     short int naxis = 2; //number of axes
     long int nelements = (long int)(nx*ny);
     long int naxes[2] = {nx, ny};
     if(get_head == 0){
          fits_create_img(fptr, LONG_IMG, naxis, naxes, &fio_err);
          if (fio_err != 0){
               printf("newfits_ fitsio error in create_image: %d\n", fio_err);
               fits_close_file(fptr, &fio_err); 
               if(get_head == 1) fits_close_file(old_fptr, &fio_err);
               return;
          } 
     }         
   
     //recast 2d to 1d array so it is done properly
     int* pic_ptr = malloc_int_1darr(nx*ny);
     recast_int_2dto1darr(ny, nx, pic_ptr, pic);

     //write the array
     fits_write_img(fptr, TINT, fpixel, nelements, 
                    pic_ptr, &fio_err); 
     if (fio_err != 0){
          printf("newfits_ fitsio error in write_image: %d\n", fio_err);
          fits_close_file(fptr, &fio_err); 
          if(get_head == 1) fits_close_file(old_fptr, &fio_err);
          return;
     }          

     free(pic_ptr);

     fits_close_file(fptr, &fio_err); 
     if (fio_err != 0){
          printf("newfits_ fitsio error in close_file (new): %d\n", fio_err);
          return;
     }          

     return;
}
